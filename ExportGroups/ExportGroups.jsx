#target photoshop/*    ExportGroups.jsx        This photoshop tool provides a quick way to export your current document    to specific target formats. ExportGroups will save out layer groups with a pre-    pending tilda ( ~ ) character in their name. The group is merge and resized to    a user specified size. Save it fast can save out to JPG, PNG, and TGA.        Document_Name + _ + ( Group_Name - '~')              Example:            Document Name: 'trash_can'            Group Name: '~diffuse'                        Exported Filename: 'trash_can_diffuse'                             TODO:            - override save HOTKEY for tool use.            - save last 5 export settings for a file.            - more user feedback.  */  /* Get Group Layers  return all layer sets wiht a "~" prepending the layer name */function getGroupLayers(){    var key = '~';    var curDoc = app.activeDocument;        var layerArray = new Array();      for( a=0; a< curDoc.layerSets.length; a++){        if (curDoc.layerSets[a].name[0] == key)            layerArray.push(curDoc.layerSets[a]);    }        return layerArray;}function resizeDocument( w, h ){        if (typeof w != 'number' && typeof h != 'number')         return false;        var curDoc = app.activeDocument;        // strict resize to exactly what was provided    curDoc.resizeImage(UnitValue(w,'px'),UnitValue(h,"px"),null,ResampleMethod.BICUBIC);            return true;}function loadXMPLibrary(){   if ( !ExternalObject.AdobeXMPScript ){      try{         ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');      }catch (e){         alert("Can't load XMP Script Library");         return false;      }   }   return true;}function unloadXMPLibrary(){   if( ExternalObject.AdobeXMPScript ) {      try{         ExternalObject.AdobeXMPScript.unload();         ExternalObject.AdobeXMPScript = undefined;      }catch (e){         alert("Can't unload XMP Script Library");      }   }}var getKeys = function(obj){   var keys = [];   for(var key in obj){      keys.push(key);   }   return keys;}function getMetadata(params){       // extract params    var paramTokens = params.split(',');    var namespaceURI = paramTokens[0];    var prefix = paramTokens[1];       var sifXMP = new Namespace(prefix,namespaceURI);	    var xml = "<object>";      if( !app.activeDocument || !loadXMPLibrary()){        xml += convertToXML("", "curDir");        xml += convertToXML("", "fileType");        xml += convertToXML("", "width");        xml += convertToXML("", "height");         xml += convertToXML("", "saveAlpha");         xml += convertToXML("", "interlace");         xml += convertToXML("", "quality");    } else {        var xmp;      // try to find XMP data on document      try {          xmp = new XMPMeta(app.activeDocument.xmpMetadata.rawData);      } catch(e) {         xml += convertToXML("", "curDir");         xml += convertToXML("", "fileType");         xml += convertToXML("", "width");         xml += convertToXML("", "height");         xml += convertToXML("", "saveAlpha");         xml += convertToXML("", "interlace");         xml += convertToXML("", "quality");         xml += "</object>";         unloadXMPLibrary();         return xml;      }         // xmp data found retieve data      try {         xml += convertToXML(            xmp.getProperty(namespaceURI, "curDir").toString(), "curDir");      } catch(e) {        xml += convertToXML("", "curDir");            }         try {         xml += convertToXML(xmp.getProperty(namespaceURI, "fileType").toString(), "fileType");      } catch(e) {          xml += convertToXML("", "fileType");      }            try {         xml += convertToXML(xmp.getProperty(namespaceURI, "width").toString(), "width");      } catch(e) {        xml += convertToXML("", "width");      }            try {         xml += convertToXML(xmp.getProperty(namespaceURI, "height").toString(), "height");      } catch(e) {           xml += convertToXML("", "height");      }            try {         xml += convertToXML(xmp.getProperty(namespaceURI, "saveAlpha").toString(), "saveAlpha");      } catch(e) {           xml += convertToXML("", "saveAlpha");      }         try {         xml += convertToXML(xmp.getProperty(namespaceURI, "interlace").toString(), "interlace");      } catch(e) {           xml += convertToXML("", "interlace");      }         try {         xml += convertToXML(xmp.getProperty(namespaceURI, "quality").toString(), "quality");      } catch(e) {           xml += convertToXML("", "quality");      }      }   xml += "</object>";   unloadXMPLibrary();      return xml;}function setMetadata(params){       // extract params    var paramTokens    = params.split(',');    var namespaceURI  = paramTokens[0];    var prefix               = paramTokens[1];    var path                 = paramTokens[2];    var fileType             = paramTokens[3];    var width                = paramTokens[4];    var height              = paramTokens[5];    var saveAlpha         = paramTokens[6];    var interlace           = paramTokens[7];    var quality              = paramTokens[8];        if( !app.activeDocument || !loadXMPLibrary()){        alert("Can't place description metadata without a document.\n" + "File > New Document...");    } else {           var xmp;           try{            xmp = new XMPMeta(app.activeDocument.xmpMetadata.rawData);        } catch(e) {            xmp = new XMPMeta();        }               var sifXMP = XMPMeta.registerNamespace(namespaceURI, prefix); //new Namespace(sifNamespace,sifNamespaceURI);	             // create metadata object to iterate through properties        var metaObject = {"curDir": path, "fileType": fileType, "width":width, "height":height, "saveAlpha":saveAlpha, "interlace":interlace, "quality":quality};             // save meta data        for (metaName in metaObject){                     var metaVar = metaObject[metaName];                try{                                xmp.setProperty(namespaceURI, metaName, metaVar);            } catch(e) {                alert("Unable to place "+ metaName +" metadata on selected layer.\n" + e);            }        }        // save data back to file        app.activeDocument.xmpMetadata.rawData = xmp.serialize();    }    unloadXMPLibrary();}function exportLayerMetadata(){   var path = File.saveDialog();   var file = new File(path);   file.encoding = "UTF-8";   try{      file.open("w");      file.write(app.activeDocument.xmpMetadata.rawData.toString());   } catch(e) {      alert("Unable to write to file.\n" + e);   }   file.close();}function getLayerChangedDate(){   var metadataStrID = stringIDToTypeID("metadata");   var ref = new ActionReference();   ref.putProperty(charIDToTypeID('Prpr'), metadataStrID);   ref.putEnumerated(charIDToTypeID('Lyr '), charIDToTypeID('Ordn'),                                       charIDToTypeID('Trgt'));   var desc = executeActionGet(ref);      if (desc.hasKey(metadataStrID)){      var descMetadata = desc.getObjectValue( metadataStrID );      var timeInSeconds = descMetadata.getDouble(stringIDToTypeID("layerTime"));      var d = new Date();      d.setTime(timeInSeconds*1000.0);      return d.toLocaleString();   }}function convertToXML(property, identifier){   var type = typeof property;   var xml = '<property id = "' + identifier + '" >';      switch(type){      case "number":         xml += "<number>";         xml += property.toString();         xml += "</number>";         break;      case "boolean":         xml += "<" + property.toString() + "/>";         break;      case "string":         xml += "<string>";         xml += property.toString();         xml += "</string>";         break;      case "object":         // Object case is currently not supported         alert("Object case is currently not supported");         //xml += "<object>";         //for(var i in property)         //   xml += convertToXML(property[i],          //xml += "</object>";         break;      case "undefined":         xml += "<string>undefined</string>";         break;      default:         alert("Type " + type + " is unknown.");         return "";   }   xml += '</property>';   return xml;}function saveGroupToDocument( group, filePath, type, options, w, h){              // save group of layers to a new file of provided type         var r = false;       var alpha = null;       var curDoc = app.activeDocument;               var filename = curDoc.name.split('.')[0];       var groupName = group.name.slice(1,group.name.length); // first letter of the name shoudl  be a  "~"            // create new document       var newDoc = app.documents.add(curDoc.width,curDoc.height,72.0,filename+"_"+groupName,NewDocumentMode.RGB, DocumentFill.WHITE);              // copy group to new document       app.activeDocument = curDoc;       group = group.duplicate(newDoc);       	  if( curDoc.channels.length > 3 ){		  var alpha =curDoc.channels[3].duplicate(newDoc); 	   }             var options = saveAsOptions(type,options);               app.activeDocument = newDoc;	  	   for (a=0; a < 3; a++){		      newDoc.channels[a].visible = true;   	   }    			   if( alpha )	       alpha.visible = false;       // resize group layers       r = resizeDocument(w, h);             newDoc.flatten();       // save to provided type       filePath += "/" + newDoc.name + "." + type;       curDoc.saveAs(new File(filePath),options, false, Extension.LOWERCASE);       // destory new document       newDoc.close(SaveOptions.DONOTSAVECHANGES);}function exportThis(params) {     var completionMessage = "Empty Message";         try{            // seperate params        var paramTokens = params.split(',');        var path = paramTokens[0];        var type = paramTokens[1];        var width = paramTokens[2];        var height = paramTokens[3];        var options = paramTokens[4];                        var grps = getGroupLayers();           for (a=0; a<grps.length; a++){                  var grp = grps[a];           var startDisplayDialogs = app.displayDialogs;           app.displayDialogs = DialogModes.NO;           saveGroupToDocument(grp, path, type, options, parseInt(width), parseInt(height));                       // create a message for the user to tell them everything is ok           completionMessage = "Grouped Layers Exported to:\t"+ path + "\n";        }    }    catch( e) {        completionMessage = "Error (" + e.num + ") in file '" + e.fileName + "', line " +  e.line + ":\n" + e.message;       }    app.displayDialogs = startDisplayDialogs;            alert (completionMessage);            //return feedback to the output log. }function browseDirectory(prompt){        var dir = Folder.selectDialog(prompt);        var outXML = "<object>";        outXML += convertToXML(dir.toString(),"dir");        outXML += "</object>";               return outXML; }function saveAsOptions( type, opts ){    var options = null;       switch(type){        case "jpg":               options = new JPEGSaveOptions();            options.embedColorProfile = false;            options.quality = Number(opts);            break;        case "png":            options = new PNGSaveOptions();            options.interlaced = Boolean(opts);            break;        case "tga":            options = new TargaSaveOptions();            options.alphaChannels = Boolean(opts);            options.resolution = (opts == "true")?TargaBitsPerPixels.THIRTYTWO:TargaBitsPerPixels.TWENTYFOUR;            break;        case "gif":            options = new GIFSaveOptions();            break;        default:            //psd            alert("Type (" + type + ") not found, using PSD format");            options = new PhotoshopSaveOptions();            break;     }     return options;}       